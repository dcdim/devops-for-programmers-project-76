---
- name: Create swap file for installation
  hosts: webservers
  become: true
  tasks:
    - name: Check current swap
      ansible.builtin.command: free -h
      register: current_swap
      changed_when: false

    - name: Show current memory
      ansible.builtin.debug:
        var: current_swap.stdout

    - name: Check if swap file exists
      ansible.builtin.stat:
        path: /swapfile
      register: swapfile_stat

    # - name: Create 2GB swap file
    #   ansible.builtin.shell: |
    #     set -o pipefail
    #     sudo fallocate -l 2G /swapfile
    #     sudo chmod 600 /swapfile
    #     sudo mkswap /swapfile
    #     sudo swapon /swapfile
    #     echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab
    #     echo "Swap file created and activated"
    #   args:
    #     executable: /bin/bash
    #   when: not swapfile_stat.stat.exists

    - name: Verify swap is active
      ansible.builtin.command: free -h
      register: new_swap
      changed_when: false

    - name: Show new memory status
      ansible.builtin.debug:
        var: new_swap.stdout

- name: Fix dpkg and prepare system
  hosts: webservers
  become: true
  tasks:
    - name: Fix interrupted dpkg processes
      ansible.builtin.shell: |
        set -o pipefail
        sudo dpkg --configure -a
        sudo apt-get install -f -y
      args:
        executable: /bin/bash
      changed_when: false
      failed_when: false

    - name: Clean up apt cache
      ansible.builtin.apt:
        autoclean: true
        autoremove: true

    - name: Update package cache
      ansible.builtin.apt:
        update_cache: true
        cache_valid_time: 3600

- name: Install and configure Datadog Agent
  hosts: webservers
  become: true
  vars:
    datadog_api_key: "{{ vault_datadog_api_key }}"
    datadog_site: "{{ vault_datadog_site | default('datadoghq.eu') }}"
    datadog_http_check_url: "http://{{ ansible_host }}:{{ redmine_port | default(80) }}/"
  roles:
    - role: datadog.datadog

# - name: Clean up swap after installation (optional)
#   hosts: webservers
#   become: true
#   tasks:
#     - name: Check if swap file exists
#       ansible.builtin.stat:
#         path: /swapfile
#       register: swapfile_exists

#     - name: Remove swap file
#       ansible.builtin.shell: |
#         sudo swapoff /swapfile || true
#         sudo rm -f /swapfile || true
#         sudo sed -i '/\/swapfile/d' /etc/fstab || true
#       when: cleanup_swap | default(false) and swapfile_exists.stat.exists

- name: Install Docker using role
  hosts: all
  become: true
  roles:
    - role: geerlingguy.docker
      vars:
        docker_install_compose: true
        docker_edition: "ce"

- name: Deploy Redmine with external database
  hosts: redmine_servers
  become: true
  vars:
    container_redmine_port: "{{ redmine_port | default(80) }}"
    db_host: "{{ vault_db_host }}"
    db_port: "{{ vault_db_port }}"
    db_user: "{{ vault_postgres_user }}"
    db_password: "{{ vault_postgres_password }}"
    db_name: "{{ vault_postgres_db }}"

  tasks:
    - name: Debug what's using the port
      ansible.builtin.shell: |
        set -o pipefail
        sudo ss -tulpn | grep ":{{ container_redmine_port }} " || echo "Port {{ container_redmine_port }} is free"
      register: port_debug
      changed_when: false

    - name: Show port debug info
      ansible.builtin.debug:
        var: port_debug.stdout

    - name: Stop any Docker containers using the port
      ansible.builtin.shell: |
        set -o pipefail
        docker ps --format "table {{ '{{.Names}}' }}\t{{ '{{.Ports}}' }}" | grep ":{{ container_redmine_port }}->" | awk '{print $1}' | xargs -r docker stop
      changed_when: false
      failed_when: false

    - name: Kill processes using port
      ansible.builtin.shell: |
        sudo fuser -k {{ container_redmine_port }}/tcp || true
      changed_when: false
      failed_when: false

    - name: Wait for port to be free
      ansible.builtin.wait_for:
        host: "0.0.0.0"
        port: "{{ container_redmine_port }}"
        state: stopped
        timeout: 10

    - name: Create redmine directory
      ansible.builtin.file:
        path: "/opt/redmine-{{ inventory_hostname }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0755'

    - name: Force cleanup all Docker resources
      ansible.builtin.shell: |
        docker stop redmine-app-{{ inventory_hostname }} 2>/dev/null || true
        docker rm -f redmine-app-{{ inventory_hostname }} 2>/dev/null || true
        cd "/opt/redmine-{{ inventory_hostname }}" && docker-compose down --remove-orphans 2>/dev/null || true
        docker network prune -f 2>/dev/null || true
      changed_when: false
      failed_when: false

    - name: Wait for cleanup to complete
      ansible.builtin.pause:
        seconds: 5

    - name: Create .env file for external database
      ansible.builtin.copy:
        content: |
          # External PostgreSQL database connection
          REDMINE_DB_POSTGRES={{ db_host }}
          REDMINE_DB_PORT={{ db_port }}
          REDMINE_DB_USERNAME={{ db_user }}
          REDMINE_DB_PASSWORD={{ db_password }}
          REDMINE_DB_DATABASE={{ db_name }}
          # Redmine configuration
          REDMINE_SECRET_KEY_BASE={{ 64 | random | to_uuid }}
          REDMINE_PORT=3000
        dest: "/opt/redmine-{{ inventory_hostname }}/.env"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0640'

    - name: Create docker-compose.yml for external database
      ansible.builtin.copy:
        content: |
          services:
            redmine:
              image: redmine:5.1.2
              container_name: "redmine-app-{{ inventory_hostname }}"
              ports:
                - "{{ container_redmine_port }}:3000"
              env_file: .env
              environment:
                - REDMINE_DB_POSTGRES={{ db_host }}
                - REDMINE_DB_PORT={{ db_port }}
                - REDMINE_DB_USERNAME={{ db_user }}
                - REDMINE_DB_PASSWORD={{ db_password }}
                - REDMINE_DB_DATABASE={{ db_name }}
              volumes:
                - redmine_data:/usr/src/redmine/files
                - redmine_plugins:/usr/src/redmine/plugins
              restart: unless-stopped
              healthcheck:
                test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:3000/ || exit 1"]
                interval: 30s
                timeout: 10s
                retries: 5
                start_period: 180s

          volumes:
            redmine_data:
            redmine_plugins:
        dest: "/opt/redmine-{{ inventory_hostname }}/docker-compose.yml"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0644'

    - name: Stop and remove existing containers
      ansible.builtin.shell: |
        cd "/opt/redmine-{{ inventory_hostname }}" && docker-compose down 2>/dev/null || true
        docker rm -f redmine-app-{{ inventory_hostname }} 2>/dev/null || true
        docker network rm redmine-{{ inventory_hostname }}_default 2>/dev/null || true
      changed_when: false
      failed_when: false

    - name: Wait for containers to be fully removed
      ansible.builtin.pause:
        seconds: 5

    - name: Verify container is removed
      ansible.builtin.shell: |
        docker ps -a --filter "name=redmine-app-{{ inventory_hostname }}" --format "table {{ '{{.Names}}' }}"
      register: existing_container
      changed_when: false
      failed_when: false

    - name: Force remove if container still exists
      ansible.builtin.shell: |
        docker rm -f redmine-app-{{ inventory_hostname }} 2>/dev/null || true
      when: existing_container.stdout != ""
      changed_when: false
      failed_when: false

    - name: Wait for database to be ready
      ansible.builtin.wait_for:
        host: "{{ db_host }}"
        port: "{{ db_port }}"
        timeout: 30
        delay: 5

    - name: Check if Redmine container is already running
      ansible.builtin.shell: |
        cd "/opt/redmine-{{ inventory_hostname }}" && docker-compose ps --services --filter "status=running"
      register: running_services_check
      changed_when: false
      failed_when: false

    - name: Deploy with docker compose
      community.docker.docker_compose:
        project_src: "/opt/redmine-{{ inventory_hostname }}"
        files:
          - docker-compose.yml
        state: present
      when: "'redmine' not in running_services_check.stdout"

    - name: Wait a moment for container to initialize
      ansible.builtin.pause:
        seconds: 10

    - name: Check if container is running
      ansible.builtin.shell: |
        cd "/opt/redmine-{{ inventory_hostname }}" && docker-compose ps --services --filter "status=running"
      register: running_services
      changed_when: false
      until: "'redmine' in running_services.stdout"
      retries: 12
      delay: 10

    - name: Wait for Redmine to be accessible
      ansible.builtin.wait_for:
        port: "{{ container_redmine_port }}"
        host: "{{ ansible_host }}"
        delay: 10
        timeout: 180

    - name: Check container status
      ansible.builtin.shell: |
        cd "/opt/redmine-{{ inventory_hostname }}" && docker-compose ps
      register: compose_status
      changed_when: false

    - name: Display compose status
      ansible.builtin.debug:
        var: compose_status.stdout

    - name: Check container health
      ansible.builtin.shell: |
        cd "/opt/redmine-{{ inventory_hostname }}" && timeout 30 docker-compose logs redmine --tail=20
      register: container_logs
      changed_when: false
      failed_when: false

    - name: Display container logs
      ansible.builtin.debug:
        var: container_logs.stdout

    - name: Check for database connection issues
      ansible.builtin.shell: |
        set -o pipefail
        cd "/opt/redmine-{{ inventory_hostname }}" && docker-compose logs redmine | grep -i "postgres\|database\|db\|error\|failed\|timeout" | tail -10
      register: db_logs
      changed_when: false
      failed_when: false

    - name: Display database connection logs
      ansible.builtin.debug:
        var: db_logs.stdout

    - name: Test Redmine accessibility
      ansible.builtin.uri:
        url: "http://{{ ansible_host }}:{{ container_redmine_port }}/"
        return_content: true
        status_code: 200, 302, 401, 500
        timeout: 30
      register: redmine_test
      ignore_errors: true

    - name: Display Redmine test result
      ansible.builtin.debug:
        var: redmine_test.status

    - name: Show access information
      ansible.builtin.debug:
        msg: |
          =========================================
          Redmine Deployment Summary - {{ inventory_hostname }}
          =========================================
          Access URL: http://{{ ansible_host }}:{{ container_redmine_port }}
          Database: {{ db_host }}:{{ db_port }}/{{ db_name }}
          Container: redmine-app-{{ inventory_hostname }}
          Check database connection:
          psql "host={{ db_host }} port={{ db_port }} sslmode=verify-full dbname={{ db_name }} user={{ db_user }} target_session_attrs=read-write"
          Check container logs:
          cd /opt/redmine-{{ inventory_hostname }} && docker-compose logs redmine
          =========================================
