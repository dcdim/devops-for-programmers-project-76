---
- name: Create swap file for installation
  hosts: webservers
  become: yes
  tasks:
    - name: Check current swap
      shell: free -h
      register: current_swap

    - name: Show current memory
      debug:
        var: current_swap.stdout

    - name: Create 2GB swap file
      shell: |
        # Check if swap already exists
        if [ -f /swapfile ]; then
          echo "Swap file already exists"
          sudo swapon --show
        else
          # Create swap file
          sudo fallocate -l 2G /swapfile
          sudo chmod 600 /swapfile
          sudo mkswap /swapfile
          sudo swapon /swapfile
          echo '/swapfile none swap sw 0 0' | sudo tee -a /etc/fstab
          echo "Swap file created and activated"
        fi
      args:
        executable: /bin/bash

    - name: Verify swap is active
      shell: free -h
      register: new_swap

    - name: Show new memory status
      debug:
        var: new_swap.stdout

- name: Fix dpkg and prepare system
  hosts: webservers
  become: yes
  tasks:
    - name: Fix interrupted dpkg processes
      shell: |
        sudo dpkg --configure -a
        sudo apt-get install -f -y
      args:
        executable: /bin/bash
      ignore_errors: yes

    - name: Clean up apt cache
      apt:
        autoclean: yes
        autoremove: yes

    - name: Update package cache
      apt:
        update_cache: yes
        cache_valid_time: 3600

- name: Install and configure Datadog Agent
  hosts: webservers
  become: yes
  vars:
    datadog_api_key: "{{ vault_datadog_api_key }}"
    datadog_site: "{{ vault_datadog_site | default('datadoghq.eu') }}"
    datadog_http_check_url: "http://{{ ansible_host }}:{{ redmine_port | default(80) }}/"
  roles:
    - role: datadog.datadog

- name: Clean up swap after installation (optional)
  hosts: webservers
  become: yes
  tasks:
    - name: Remove swap file
      shell: |
        sudo swapoff /swapfile || true
        sudo rm -f /swapfile || true
        sudo sed -i '/\\/swapfile/d' /etc/fstab || true
      when: cleanup_swap | default(false)

- name: Install Docker and docker-compose
  hosts: all
  become: yes
  tasks:
    - name: Update package cache
      apt:
        update_cache: yes
        cache_valid_time: 3600

    - name: Install Docker and dependencies
      apt:
        name:
          - docker.io
          - docker-compose-plugin
        state: present

    - name: Start and enable Docker
      systemd:
        name: docker
        state: started
        enabled: yes

    - name: Add user to docker group
      user:
        name: "{{ ansible_user }}"
        groups: docker
        append: yes

- name: Deploy Redmine with external database
  hosts: redmine_servers
  become: yes
  vars:
    container_redmine_port: "{{ redmine_port | default(80) }}"
    db_host: "{{ vault_db_host }}"
    db_port: "{{ vault_db_port }}"
    db_user: "{{ vault_postgres_user }}"
    db_password: "{{ vault_postgres_password }}"
    db_name: "{{ vault_postgres_db }}"

  tasks:
    - name: Debug what's using the port
      shell: |
        sudo ss -tulpn | grep ":{{ container_redmine_port }} " || echo "Port {{ container_redmine_port }} is free"
      register: port_debug
      changed_when: false

    - name: Show port debug info
      debug:
        var: port_debug.stdout

    - name: Stop any Docker containers using the port
      shell: |
        docker ps --format "{{.Names}} {{.Ports}}" | grep ":{{ container_redmine_port }}->" | awk '{print $1}' | xargs -r docker stop
      ignore_errors: yes

    - name: Kill processes using port
      shell: |
        sudo fuser -k {{ container_redmine_port }}/tcp || true
      ignore_errors: yes

    - name: Wait for port to be free
      wait_for:
        host: "0.0.0.0"
        port: "{{ container_redmine_port }}"
        state: stopped
        timeout: 10

    - name: Create redmine directory
      file:
        path: "/opt/redmine-{{ inventory_hostname }}"
        state: directory
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"

    - name: Force cleanup all Docker resources
      shell: |
        # Принудительно останавливаем и удаляем все
        docker stop redmine-app-{{ inventory_hostname }} 2>/dev/null || true
        docker rm -f redmine-app-{{ inventory_hostname }} 2>/dev/null || true
        cd "/opt/redmine-{{ inventory_hostname }}" && docker-compose down --remove-orphans 2>/dev/null || true
        docker network prune -f 2>/dev/null || true
      ignore_errors: yes

    - name: Wait for cleanup to complete
      pause:
        seconds: 5

    - name: Create .env file for external database
      copy:
        content: |
          # External PostgreSQL database connection
          REDMINE_DB_POSTGRES={{ db_host }}
          REDMINE_DB_PORT={{ db_port }}
          REDMINE_DB_USERNAME={{ db_user }}
          REDMINE_DB_PASSWORD={{ db_password }}
          REDMINE_DB_DATABASE={{ db_name }}
          
          # Redmine configuration
          REDMINE_SECRET_KEY_BASE={{ 64 | random | to_uuid }}
          REDMINE_PORT=3000
        dest: "/opt/redmine-{{ inventory_hostname }}/.env"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"
        mode: '0640'

    - name: Create docker-compose.yml for external database
      copy:
        content: |
          services:
            redmine:
              image: redmine:5.1.2
              container_name: "redmine-app-{{ inventory_hostname }}"
              ports:
                - "{{ container_redmine_port }}:3000"
              env_file: .env
              environment:
                - REDMINE_DB_POSTGRES={{ db_host }}
                - REDMINE_DB_PORT={{ db_port }}
                - REDMINE_DB_USERNAME={{ db_user }}
                - REDMINE_DB_PASSWORD={{ db_password }}
                - REDMINE_DB_DATABASE={{ db_name }}
              volumes:
                - redmine_data:/usr/src/redmine/files
                - redmine_plugins:/usr/src/redmine/plugins
              restart: unless-stopped
              healthcheck:
                test: ["CMD-SHELL", "wget --no-verbose --tries=1 --spider http://localhost:3000/ || exit 1"]
                interval: 30s
                timeout: 10s
                retries: 5
                start_period: 180s

          volumes:
            redmine_data:
            redmine_plugins:
        dest: "/opt/redmine-{{ inventory_hostname }}/docker-compose.yml"
        owner: "{{ ansible_user }}"
        group: "{{ ansible_user }}"

    - name: Stop and remove existing containers
      shell: |
        cd "/opt/redmine-{{ inventory_hostname }}" && docker-compose down 2>/dev/null || true

        docker rm -f redmine-app-{{ inventory_hostname }} 2>/dev/null || true
        docker network rm redmine-{{ inventory_hostname }}_default 2>/dev/null || true
      ignore_errors: yes

    - name: Wait for containers to be fully removed
      pause:
        seconds: 5

    - name: Verify container is removed
      shell: |
        docker ps -a --filter "name=redmine-app-{{ inventory_hostname }}" --format "table {{"{{.Names}}"}}"
      register: existing_container
      failed_when: false

    - name: Force remove if container still exists
      shell: |
        docker rm -f redmine-app-{{ inventory_hostname }} 2>/dev/null || true
      when: existing_container.stdout != ""
      ignore_errors: yes

    - name: Wait for database to be ready
      wait_for:
        host: "{{ db_host }}"
        port: "{{ db_port }}"
        timeout: 30
        delay: 5

    - name: Deploy with docker compose
      shell: |
        cd "/opt/redmine-{{ inventory_hostname }}" && docker-compose up -d
      args:
        executable: /bin/bash

    - name: Wait a moment for container to initialize
      pause:
        seconds: 10

    - name: Check if container is running
      shell: |
        cd "/opt/redmine-{{ inventory_hostname }}" && docker-compose ps --services --filter "status=running"
      register: running_services
      until: "'redmine' in running_services.stdout"
      retries: 12
      delay: 10

    - name: Wait for Redmine to be accessible
      wait_for:
        port: "{{ container_redmine_port }}"
        host: "{{ ansible_host }}"
        delay: 10
        timeout: 180

    - name: Check container status
      shell: |
        cd "/opt/redmine-{{ inventory_hostname }}" && docker-compose ps
      register: compose_status

    - name: Display compose status
      debug:
        var: compose_status.stdout

    - name: Check container health
      shell: |
        cd "/opt/redmine-{{ inventory_hostname }}" && timeout 30 docker-compose logs redmine --tail=20
      register: container_logs
      failed_when: false

    - name: Display container logs
      debug:
        var: container_logs.stdout

    - name: Check for database connection issues
      shell: |
        cd "/opt/redmine-{{ inventory_hostname }}" && docker-compose logs redmine | grep -i "postgres\|database\|db\|error\|failed\|timeout" | tail -10
      register: db_logs
      failed_when: false

    - name: Display database connection logs
      debug:
        var: db_logs.stdout

    - name: Test Redmine accessibility
      uri:
        url: "http://{{ ansible_host }}:{{ container_redmine_port }}/"
        return_content: yes
        status_code: 200, 302, 401, 500
        timeout: 30
      register: redmine_test
      ignore_errors: yes

    - name: Display Redmine test result
      debug:
        var: redmine_test.status

    - name: Show access information
      debug:
        msg: |
          =========================================
          Redmine Deployment Summary - {{ inventory_hostname }}
          =========================================
          Access URL: http://{{ ansible_host }}:{{ container_redmine_port }}
          Database: {{ db_host }}:{{ db_port }}/{{ db_name }}
          Container: redmine-app-{{ inventory_hostname }}
          
          Check database connection:
          psql "host={{ db_host }} port={{ db_port }} sslmode=verify-full dbname={{ db_name }} user={{ db_user }} target_session_attrs=read-write"
          
          Check container logs:
          cd /opt/redmine-{{ inventory_hostname }} && docker-compose logs redmine
          =========================================